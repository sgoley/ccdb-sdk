# coding: utf-8

"""
    Consumer Complaint Database API

    The API for searching the Consumer Complaint Database

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Complaint(BaseModel):
    """
    Complaint
    """ # noqa: E501
    company: Optional[StrictStr] = Field(default=None, description="The complaint is about this company")
    company_public_response: Optional[StrictStr] = Field(default=None, description="The company's optional, public-facing response to a consumer's complaint")
    company_response: Optional[StrictStr] = Field(default=None, description="The response from the company about this complaint")
    complaint_id: Optional[StrictInt] = Field(default=None, description="The unique identification number for a complaint")
    complaint_what_happened: Optional[StrictStr] = Field(default=None, description="A description of the complaint provided by the consumer")
    consumer_consent_provided: Optional[StrictStr] = Field(default=None, description="Identifies whether the consumer opted in to publish their complaint narrative")
    consumer_disputed: Optional[StrictStr] = Field(default=None, description="Whether the consumer disputed the company's response")
    date_received: Optional[date] = Field(default=None, description="The date the CFPB received the complaint")
    date_sent_to_company: Optional[StrictStr] = Field(default=None, description="The date the CFPB sent the complaint to the company")
    has_narrative: Optional[StrictBool] = Field(default=None, description="Indicates this complaint has a narrative")
    issue: Optional[StrictStr] = Field(default=None, description="The issue the consumer identified in the complaint")
    product: Optional[StrictStr] = Field(default=None, description="The type of product the consumer identified in the complaint")
    state: Optional[StrictStr] = Field(default=None, description="The state of the mailing address provided by the consumer")
    sub_issue: Optional[StrictStr] = Field(default=None, description="The sub-issue the consumer identified in the complaint")
    sub_product: Optional[StrictStr] = Field(default=None, description="The type of sub-product the consumer identified in the complaint")
    submitted_via: Optional[StrictStr] = Field(default=None, description="How the complaint was submitted to the CFPB")
    tags: Optional[StrictStr] = Field(default=None, description="Data that supports easier searching and sorting of complaints")
    timely: Optional[StrictStr] = Field(default=None, description="Indicates whether the company gave a timely response or not")
    zip_code: Optional[StrictStr] = Field(default=None, description="The mailing ZIP code provided by the consumer")
    __properties: ClassVar[List[str]] = ["company", "company_public_response", "company_response", "complaint_id", "complaint_what_happened", "consumer_consent_provided", "consumer_disputed", "date_received", "date_sent_to_company", "has_narrative", "issue", "product", "state", "sub_issue", "sub_product", "submitted_via", "tags", "timely", "zip_code"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Complaint from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Complaint from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "company": obj.get("company"),
            "company_public_response": obj.get("company_public_response"),
            "company_response": obj.get("company_response"),
            "complaint_id": obj.get("complaint_id"),
            "complaint_what_happened": obj.get("complaint_what_happened"),
            "consumer_consent_provided": obj.get("consumer_consent_provided"),
            "consumer_disputed": obj.get("consumer_disputed"),
            "date_received": obj.get("date_received"),
            "date_sent_to_company": obj.get("date_sent_to_company"),
            "has_narrative": obj.get("has_narrative"),
            "issue": obj.get("issue"),
            "product": obj.get("product"),
            "state": obj.get("state"),
            "sub_issue": obj.get("sub_issue"),
            "sub_product": obj.get("sub_product"),
            "submitted_via": obj.get("submitted_via"),
            "tags": obj.get("tags"),
            "timely": obj.get("timely"),
            "zip_code": obj.get("zip_code")
        })
        return _obj


